% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/read_excel.R
\name{read_timeseries_excel}
\alias{read_timeseries_excel}
\title{Read a time series from an Excel workbook}
\usage{
read_timeseries_excel(
  file,
  sheet,
  date_col,
  col_trans,
  date_order = "dmy",
  force_numeric = TRUE,
  comma_rep = "."
)
}
\arguments{
\item{file}{Path to the Excel workbook. Typically you pass a filename
relative to \code{getOption("fundsr.data_dir")}, or an absolute path.}

\item{sheet}{Sheet identifier to read from (sheet name or 1-based index).}

\item{date_col}{String used to detect the header row and identify the
date column (matched via regex against cell contents for header-row
detection, and against column names after headers are assigned).}

\item{col_trans}{Named character vector (or list) mapping output column names
to regex patterns used to select columns from the sheet. Names are returned
column names; values are patterns matched against header names.}

\item{date_order}{Character scalar indicating day/month/year order used to
generate candidate date formats for parsing text dates (passed to
\code{make_date_fmts()}). Default is \code{"dmy"}.}

\item{force_numeric}{Logical. If \code{TRUE} (default), always replace matched
value columns with their numeric coercions (non-parsable values become
\code{NA}). If \code{FALSE}, only replace when coercion succeeds for all non-\code{NA}
values.}

\item{comma_rep}{Character scalar used when converting character numerics:
commas are replaced by this string before conversion. Default \code{"."} (treat
comma as decimal separator).}
}
\value{
A tibble with a \code{date} column (class \code{Date}) and the selected value
columns (possibly numeric), with names determined by \code{col_trans}.
}
\description{
Reads an Excel sheet, detects the header row by searching for a date header,
parses the date column, selects/renames value columns by regex, and optionally
coerces value columns to numeric.
}
\details{
The sheet is read using \code{read_excel_or_xml()} (tries \code{readxl} first, then an
XML fallback). Completely empty columns are dropped. The first row containing
\code{date_col} (any cell match) is treated as the header row; data starts
below it.

Date parsing:
\itemize{
\item If the detected date column is numeric (or looks numeric), it is interpreted
as an Excel serial date with origin \code{"1899-12-30"}.
\item Otherwise the date strings are cleaned (truncated to 24 chars, \code{"Sept"} â†’
\code{"Sep"}, trailing \code{" 12:00:00 AM"} removed) and parsed with \code{as.Date()} using
formats from \code{make_date_fmts(date_order)}.
After parsing, the function drops all rows from the first unparseable date
onward (i.e., it truncates at the first \code{NA} date), then filters remaining
\code{NA} dates.
}

Column selection/renaming:
\code{col_trans} maps desired output names to regex patterns matched against the
detected header names. If a pattern matches multiple columns, they are kept
and suffixed (\code{name}, \code{name2}, \code{name3}, ...).

Numeric coercion:
For non-date columns, character values have \code{"$"} / \code{"USD "} stripped, commas
replaced by \code{comma_rep}, then are converted with \code{as.numeric()}. If
\code{force_numeric = TRUE}, the converted numeric column is kept even if some
values fail to parse; otherwise the column is only replaced when all non-\code{NA}
values parse successfully.
}
\examples{
\dontrun{
x <- read_timeseries_excel(
  file = "example.xlsx",
  sheet = 1,
  date_col = "^Date$",
  col_trans = c(nav = "NAV", tr = "TR"),
  date_order = "dmy"
)
}
}
\seealso{
\code{\link[=read_timeseries]{read_timeseries()}} for CSV/TSV time series import.
}
